{"ast":null,"code":"import axios from 'axios';\n// API-basURL\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001/api';\n\n// Simulerad data för demonstration och fallback\nconst mockUniversities = [{\n  id: 'kth',\n  name: 'Kungliga Tekniska Högskolan'\n}, {\n  id: 'su',\n  name: 'Stockholms Universitet'\n}, {\n  id: 'uu',\n  name: 'Uppsala Universitet'\n}, {\n  id: 'lu',\n  name: 'Lunds Universitet'\n}, {\n  id: 'gu',\n  name: 'Göteborgs Universitet'\n}];\n\n// Svenska regioner\nconst mockRegions = [{\n  id: 'stockholm',\n  name: 'Stockholm'\n}, {\n  id: 'uppsala',\n  name: 'Uppsala'\n}, {\n  id: 'skane',\n  name: 'Skåne'\n}, {\n  id: 'vastra_gotaland',\n  name: 'Västra Götaland'\n}, {\n  id: 'ostergotland',\n  name: 'Östergötland'\n}, {\n  id: 'norrbotten',\n  name: 'Norrbotten'\n}, {\n  id: 'vasterbotten',\n  name: 'Västerbotten'\n}, {\n  id: 'jamtland',\n  name: 'Jämtland'\n}, {\n  id: 'dalarna',\n  name: 'Dalarna'\n}, {\n  id: 'orebro',\n  name: 'Örebro'\n}, {\n  id: 'vastmanland',\n  name: 'Västmanland'\n}, {\n  id: 'sodermanland',\n  name: 'Södermanland'\n}, {\n  id: 'gavleborg',\n  name: 'Gävleborg'\n}, {\n  id: 'varmland',\n  name: 'Värmland'\n}, {\n  id: 'jonkoping',\n  name: 'Jönköping'\n}, {\n  id: 'kalmar',\n  name: 'Kalmar'\n}, {\n  id: 'kronoberg',\n  name: 'Kronoberg'\n}, {\n  id: 'blekinge',\n  name: 'Blekinge'\n}, {\n  id: 'halland',\n  name: 'Halland'\n}, {\n  id: 'gotland',\n  name: 'Gotland'\n}, {\n  id: 'vasternorrland',\n  name: 'Västernorrland'\n}];\n\n// Program med typisk könsfördelning\nconst programGenderBias = {\n  'cs': {\n    male: 0.75,\n    female: 0.23,\n    other: 0.02\n  },\n  // Datavetenskap - mansdominerad\n  'eng': {\n    male: 0.65,\n    female: 0.33,\n    other: 0.02\n  },\n  // Civilingenjör - mansdominerad\n  'med': {\n    male: 0.35,\n    female: 0.63,\n    other: 0.02\n  } // Läkarprogrammet - kvinnodominerad\n};\n\n// Generera simulerad statistik för demonstration\nconst generateMockStatistics = () => {\n  const statistics = [];\n  mockUniversities.forEach(university => {\n    const programs = [{\n      id: `${university.id}-cs`,\n      name: 'Datavetenskap'\n    }, {\n      id: `${university.id}-eng`,\n      name: 'Civilingenjör'\n    }, {\n      id: `${university.id}-med`,\n      name: 'Läkarprogrammet'\n    }];\n    programs.forEach(program => {\n      for (let year = 2010; year <= 2023; year++) {\n        // Simulera en trend med ökande antal sökande\n        const baseApplicants = 500 + Math.floor(Math.random() * 500);\n        const yearFactor = (year - 2010) * 50;\n        const randomFactor = Math.floor(Math.random() * 200) - 100;\n        const applicants = baseApplicants + yearFactor + randomFactor;\n        const acceptedStudents = Math.floor(applicants * (0.1 + Math.random() * 0.2));\n        const firstHandApplicants = Math.floor(applicants * (0.4 + Math.random() * 0.3));\n        statistics.push({\n          id: `${program.id}-${year}`,\n          name: program.name,\n          universityId: university.id,\n          year,\n          applicants,\n          acceptedStudents,\n          firstHandApplicants\n        });\n      }\n    });\n  });\n  return statistics;\n};\n\n// Generera simulerad geografisk fördelning\nconst generateMockGeographicDistribution = () => {\n  const distributions = [];\n  mockUniversities.forEach(university => {\n    for (let year = 2010; year <= 2023; year++) {\n      // Skapa en fördelning baserad på lärosätets geografiska läge\n      // Högre procent från närliggande regioner\n      const regionData = [];\n      let totalPercentage = 0;\n\n      // Bestäm vilka regioner som är \"nära\" lärosätet\n      const nearbyRegions = [];\n      switch (university.id) {\n        case 'kth':\n        case 'su':\n          nearbyRegions.push('stockholm', 'uppsala', 'sodermanland');\n          break;\n        case 'uu':\n          nearbyRegions.push('uppsala', 'stockholm', 'vastmanland');\n          break;\n        case 'lu':\n          nearbyRegions.push('skane', 'blekinge', 'halland');\n          break;\n        case 'gu':\n          nearbyRegions.push('vastra_gotaland', 'halland', 'varmland');\n          break;\n      }\n\n      // Fördela sökande över regioner\n      mockRegions.forEach(region => {\n        let percentage;\n        if (nearbyRegions.includes(region.id)) {\n          // Högre procent från närliggande regioner (10-25%)\n          percentage = 10 + Math.random() * 15;\n        } else {\n          // Lägre procent från andra regioner (1-5%)\n          percentage = 1 + Math.random() * 4;\n        }\n\n        // Justera för att säkerställa att summan blir 100%\n        totalPercentage += percentage;\n\n        // Simulera antalet sökande baserat på procent\n        // Anta att vi har totalt 1000-3000 sökande per år\n        const totalApplicants = 1000 + Math.floor(Math.random() * 2000);\n        const applicantCount = Math.floor(percentage / 100 * totalApplicants);\n        regionData.push({\n          regionId: region.id,\n          regionName: region.name,\n          applicantCount,\n          percentage\n        });\n      });\n\n      // Normalisera procentandelarna så att summan blir 100%\n      regionData.forEach(data => {\n        data.percentage = data.percentage / totalPercentage * 100;\n      });\n\n      // Sortera efter antal sökande (fallande)\n      regionData.sort((a, b) => b.applicantCount - a.applicantCount);\n      distributions.push({\n        universityId: university.id,\n        year,\n        regionData\n      });\n    }\n  });\n  return distributions;\n};\n\n// Generera simulerad könsfördelning\nconst generateMockGenderDistribution = () => {\n  const distributions = [];\n\n  // För varje lärosäte\n  mockUniversities.forEach(university => {\n    // För varje år\n    for (let year = 2010; year <= 2023; year++) {\n      // För varje program\n      const programs = [{\n        id: `${university.id}-cs`,\n        name: 'Datavetenskap',\n        type: 'cs'\n      }, {\n        id: `${university.id}-eng`,\n        name: 'Civilingenjör',\n        type: 'eng'\n      }, {\n        id: `${university.id}-med`,\n        name: 'Läkarprogrammet',\n        type: 'med'\n      }];\n\n      // Lägg till en total för hela lärosätet\n      const totalApplicants = 1500 + Math.floor(Math.random() * 1000) + (year - 2010) * 100;\n      const totalAccepted = Math.floor(totalApplicants * (0.2 + Math.random() * 0.1));\n\n      // Beräkna genomsnittlig könsfördelning för lärosätet\n      // Anta en gradvis förändring mot jämnare könsfördelning över tid\n      const yearFactor = (year - 2010) * 0.005; // Små förändringar per år\n\n      // Genomsnittlig könsfördelning för lärosätet\n      let maleBias = 0.55 - yearFactor; // Startar med 55% män, minskar något över tid\n      let femaleBias = 0.43 + yearFactor; // Startar med 43% kvinnor, ökar något över tid\n      const otherBias = 0.02; // Konstant 2% övriga\n\n      // Justera för att säkerställa att summan blir 100%\n      const totalBias = maleBias + femaleBias + otherBias;\n      maleBias = maleBias / totalBias;\n      femaleBias = femaleBias / totalBias;\n\n      // Lägg till total för lärosätet\n      distributions.push({\n        universityId: university.id,\n        year,\n        maleApplicants: Math.floor(totalApplicants * maleBias),\n        femaleApplicants: Math.floor(totalApplicants * femaleBias),\n        otherApplicants: Math.floor(totalApplicants * otherBias),\n        maleAccepted: Math.floor(totalAccepted * maleBias),\n        femaleAccepted: Math.floor(totalAccepted * femaleBias),\n        otherAccepted: Math.floor(totalAccepted * otherBias)\n      });\n\n      // Lägg till för varje program\n      programs.forEach(program => {\n        const programApplicants = 400 + Math.floor(Math.random() * 300) + (year - 2010) * 30;\n        const programAccepted = Math.floor(programApplicants * (0.15 + Math.random() * 0.15));\n\n        // Hämta programmets typiska könsfördelning\n        const genderBias = programGenderBias[program.type];\n\n        // Justera för förändringar över tid (gradvis jämnare fördelning)\n        let maleRatio = genderBias.male - yearFactor * (genderBias.male > 0.5 ? 1 : -1);\n        let femaleRatio = genderBias.female + yearFactor * (genderBias.female < 0.5 ? 1 : -1);\n        const otherRatio = genderBias.other;\n\n        // Normalisera för att säkerställa att summan blir 100%\n        const totalRatio = maleRatio + femaleRatio + otherRatio;\n        maleRatio = maleRatio / totalRatio;\n        femaleRatio = femaleRatio / totalRatio;\n        distributions.push({\n          universityId: university.id,\n          year,\n          programId: program.id,\n          programName: program.name,\n          maleApplicants: Math.floor(programApplicants * maleRatio),\n          femaleApplicants: Math.floor(programApplicants * femaleRatio),\n          otherApplicants: Math.floor(programApplicants * otherRatio),\n          maleAccepted: Math.floor(programAccepted * maleRatio),\n          femaleAccepted: Math.floor(programAccepted * femaleRatio),\n          otherAccepted: Math.floor(programAccepted * otherRatio)\n        });\n      });\n    }\n  });\n  return distributions;\n};\nconst mockStatistics = generateMockStatistics();\nconst mockGeographicDistributions = generateMockGeographicDistribution();\nconst mockGenderDistributions = generateMockGenderDistribution();\n\n// Hämta alla lärosäten\nexport const getUniversities = async () => {\n  try {\n    // Försök hämta från API först\n    const response = await axios.get(`${API_BASE_URL}/universities`);\n    return response.data;\n  } catch (error) {\n    console.warn('Kunde inte hämta lärosäten från API, använder mockdata istället', error);\n    // Fallback till mockdata om API-anropet misslyckas\n    return Promise.resolve(mockUniversities);\n  }\n};\n\n// Hämta alla regioner\nexport const getRegions = async () => {\n  try {\n    const response = await axios.get(`${API_BASE_URL}/regions`);\n    return response.data;\n  } catch (error) {\n    console.warn('Kunde inte hämta regioner från API, använder mockdata istället', error);\n    return Promise.resolve(mockRegions);\n  }\n};\n\n// Hämta statistik baserat på filter\nexport const getStatistics = async filter => {\n  try {\n    const response = await axios.get(`${API_BASE_URL}/statistics`, {\n      params: filter\n    });\n    return response.data;\n  } catch (error) {\n    console.warn('Kunde inte hämta statistik från API, använder mockdata istället', error);\n\n    // Fallback till mockdata\n    let filteredStats = [...mockStatistics];\n    if (filter.universityId) {\n      filteredStats = filteredStats.filter(stat => stat.universityId === filter.universityId);\n    }\n    if (filter.fromYear) {\n      filteredStats = filteredStats.filter(stat => stat.year >= filter.fromYear);\n    }\n    if (filter.toYear) {\n      filteredStats = filteredStats.filter(stat => stat.year <= filter.toYear);\n    }\n    if (filter.programId) {\n      filteredStats = filteredStats.filter(stat => stat.id.startsWith(filter.programId));\n    }\n    return Promise.resolve(filteredStats);\n  }\n};\n\n// Hämta aggregerad statistik för ett lärosäte\nexport const getUniversityStatistics = async universityId => {\n  try {\n    const response = await axios.get(`${API_BASE_URL}/universities/${universityId}/statistics`);\n    return response.data;\n  } catch (error) {\n    console.warn('Kunde inte hämta universitetsstatistik från API, använder mockdata istället', error);\n\n    // Fallback till mockdata\n    const stats = await getStatistics({\n      universityId\n    });\n\n    // Gruppera efter år\n    const yearGroups = {};\n    stats.forEach(stat => {\n      if (!yearGroups[stat.year]) {\n        yearGroups[stat.year] = [];\n      }\n      yearGroups[stat.year].push(stat);\n    });\n\n    // Skapa aggregerad statistik per år\n    const universityStats = Object.keys(yearGroups).map(yearStr => {\n      const year = parseInt(yearStr);\n      const programs = yearGroups[year];\n      const totalApplicants = programs.reduce((sum, prog) => sum + prog.applicants, 0);\n      const totalAcceptedStudents = programs.reduce((sum, prog) => sum + prog.acceptedStudents, 0);\n      return {\n        universityId,\n        year,\n        totalApplicants,\n        totalAcceptedStudents,\n        programs\n      };\n    });\n    return universityStats.sort((a, b) => a.year - b.year);\n  }\n};\n\n// Hämta geografisk fördelning för ett lärosäte\nexport const getGeographicDistribution = async (universityId, year) => {\n  try {\n    const params = year ? {\n      year\n    } : {};\n    const response = await axios.get(`${API_BASE_URL}/universities/${universityId}/geographic-distribution`, {\n      params\n    });\n    return response.data;\n  } catch (error) {\n    console.warn('Kunde inte hämta geografisk fördelning från API, använder mockdata istället', error);\n\n    // Fallback till mockdata\n    let filteredDistributions = [...mockGeographicDistributions].filter(dist => dist.universityId === universityId);\n    if (year) {\n      filteredDistributions = filteredDistributions.filter(dist => dist.year === year);\n    }\n    return Promise.resolve(filteredDistributions.sort((a, b) => a.year - b.year));\n  }\n};\n\n// Hämta könsfördelning för ett lärosäte\nexport const getGenderDistribution = async (universityId, year, programId) => {\n  try {\n    const params = {\n      year,\n      programId\n    };\n    const response = await axios.get(`${API_BASE_URL}/universities/${universityId}/gender-distribution`, {\n      params\n    });\n    return response.data;\n  } catch (error) {\n    console.warn('Kunde inte hämta könsfördelning från API, använder mockdata istället', error);\n\n    // Fallback till mockdata\n    let filteredDistributions = [...mockGenderDistributions].filter(dist => dist.universityId === universityId);\n    if (year) {\n      filteredDistributions = filteredDistributions.filter(dist => dist.year === year);\n    }\n    if (programId) {\n      filteredDistributions = filteredDistributions.filter(dist => dist.programId === programId);\n    }\n    return Promise.resolve(filteredDistributions.sort((a, b) => {\n      // Sortera först efter år\n      if (a.year !== b.year) return a.year - b.year;\n\n      // Sedan sortera så att totalen för lärosätet kommer först\n      if (!a.programId && b.programId) return -1;\n      if (a.programId && !b.programId) return 1;\n\n      // Slutligen sortera program alfabetiskt\n      if (a.programName && b.programName) {\n        return a.programName.localeCompare(b.programName);\n      }\n      return 0;\n    }));\n  }\n};","map":{"version":3,"names":["axios","API_BASE_URL","process","env","REACT_APP_API_BASE_URL","mockUniversities","id","name","mockRegions","programGenderBias","male","female","other","generateMockStatistics","statistics","forEach","university","programs","program","year","baseApplicants","Math","floor","random","yearFactor","randomFactor","applicants","acceptedStudents","firstHandApplicants","push","universityId","generateMockGeographicDistribution","distributions","regionData","totalPercentage","nearbyRegions","region","percentage","includes","totalApplicants","applicantCount","regionId","regionName","data","sort","a","b","generateMockGenderDistribution","type","totalAccepted","maleBias","femaleBias","otherBias","totalBias","maleApplicants","femaleApplicants","otherApplicants","maleAccepted","femaleAccepted","otherAccepted","programApplicants","programAccepted","genderBias","maleRatio","femaleRatio","otherRatio","totalRatio","programId","programName","mockStatistics","mockGeographicDistributions","mockGenderDistributions","getUniversities","response","get","error","console","warn","Promise","resolve","getRegions","getStatistics","filter","params","filteredStats","stat","fromYear","toYear","startsWith","getUniversityStatistics","stats","yearGroups","universityStats","Object","keys","map","yearStr","parseInt","reduce","sum","prog","totalAcceptedStudents","getGeographicDistribution","filteredDistributions","dist","getGenderDistribution","localeCompare"],"sources":["C:/Users/saak0033/source/repos/IP/src/services/statisticsService.ts"],"sourcesContent":["import axios from 'axios';\r\nimport { University, ProgramStatistics, UniversityStatistics, StatisticsFilter, GeographicDistribution, RegionData, Region, GenderDistribution } from '../models/types';\r\n\r\n// API-basURL\r\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001/api';\r\n\r\n// Simulerad data för demonstration och fallback\r\nconst mockUniversities: University[] = [\r\n  { id: 'kth', name: 'Kungliga Tekniska Högskolan' },\r\n  { id: 'su', name: 'Stockholms Universitet' },\r\n  { id: 'uu', name: 'Uppsala Universitet' },\r\n  { id: 'lu', name: 'Lunds Universitet' },\r\n  { id: 'gu', name: 'Göteborgs Universitet' },\r\n];\r\n\r\n// Svenska regioner\r\nconst mockRegions: Region[] = [\r\n  { id: 'stockholm', name: 'Stockholm' },\r\n  { id: 'uppsala', name: 'Uppsala' },\r\n  { id: 'skane', name: 'Skåne' },\r\n  { id: 'vastra_gotaland', name: 'Västra Götaland' },\r\n  { id: 'ostergotland', name: 'Östergötland' },\r\n  { id: 'norrbotten', name: 'Norrbotten' },\r\n  { id: 'vasterbotten', name: 'Västerbotten' },\r\n  { id: 'jamtland', name: 'Jämtland' },\r\n  { id: 'dalarna', name: 'Dalarna' },\r\n  { id: 'orebro', name: 'Örebro' },\r\n  { id: 'vastmanland', name: 'Västmanland' },\r\n  { id: 'sodermanland', name: 'Södermanland' },\r\n  { id: 'gavleborg', name: 'Gävleborg' },\r\n  { id: 'varmland', name: 'Värmland' },\r\n  { id: 'jonkoping', name: 'Jönköping' },\r\n  { id: 'kalmar', name: 'Kalmar' },\r\n  { id: 'kronoberg', name: 'Kronoberg' },\r\n  { id: 'blekinge', name: 'Blekinge' },\r\n  { id: 'halland', name: 'Halland' },\r\n  { id: 'gotland', name: 'Gotland' },\r\n  { id: 'vasternorrland', name: 'Västernorrland' },\r\n];\r\n\r\n// Program med typisk könsfördelning\r\nconst programGenderBias: { [key: string]: { male: number, female: number, other: number } } = {\r\n  'cs': { male: 0.75, female: 0.23, other: 0.02 },  // Datavetenskap - mansdominerad\r\n  'eng': { male: 0.65, female: 0.33, other: 0.02 }, // Civilingenjör - mansdominerad\r\n  'med': { male: 0.35, female: 0.63, other: 0.02 }, // Läkarprogrammet - kvinnodominerad\r\n};\r\n\r\n// Generera simulerad statistik för demonstration\r\nconst generateMockStatistics = (): ProgramStatistics[] => {\r\n  const statistics: ProgramStatistics[] = [];\r\n  \r\n  mockUniversities.forEach(university => {\r\n    const programs = [\r\n      { id: `${university.id}-cs`, name: 'Datavetenskap' },\r\n      { id: `${university.id}-eng`, name: 'Civilingenjör' },\r\n      { id: `${university.id}-med`, name: 'Läkarprogrammet' },\r\n    ];\r\n    \r\n    programs.forEach(program => {\r\n      for (let year = 2010; year <= 2023; year++) {\r\n        // Simulera en trend med ökande antal sökande\r\n        const baseApplicants = 500 + Math.floor(Math.random() * 500);\r\n        const yearFactor = (year - 2010) * 50;\r\n        const randomFactor = Math.floor(Math.random() * 200) - 100;\r\n        \r\n        const applicants = baseApplicants + yearFactor + randomFactor;\r\n        const acceptedStudents = Math.floor(applicants * (0.1 + Math.random() * 0.2));\r\n        const firstHandApplicants = Math.floor(applicants * (0.4 + Math.random() * 0.3));\r\n        \r\n        statistics.push({\r\n          id: `${program.id}-${year}`,\r\n          name: program.name,\r\n          universityId: university.id,\r\n          year,\r\n          applicants,\r\n          acceptedStudents,\r\n          firstHandApplicants\r\n        });\r\n      }\r\n    });\r\n  });\r\n  \r\n  return statistics;\r\n};\r\n\r\n// Generera simulerad geografisk fördelning\r\nconst generateMockGeographicDistribution = (): GeographicDistribution[] => {\r\n  const distributions: GeographicDistribution[] = [];\r\n  \r\n  mockUniversities.forEach(university => {\r\n    for (let year = 2010; year <= 2023; year++) {\r\n      // Skapa en fördelning baserad på lärosätets geografiska läge\r\n      // Högre procent från närliggande regioner\r\n      const regionData: RegionData[] = [];\r\n      let totalPercentage = 0;\r\n      \r\n      // Bestäm vilka regioner som är \"nära\" lärosätet\r\n      const nearbyRegions: string[] = [];\r\n      switch (university.id) {\r\n        case 'kth':\r\n        case 'su':\r\n          nearbyRegions.push('stockholm', 'uppsala', 'sodermanland');\r\n          break;\r\n        case 'uu':\r\n          nearbyRegions.push('uppsala', 'stockholm', 'vastmanland');\r\n          break;\r\n        case 'lu':\r\n          nearbyRegions.push('skane', 'blekinge', 'halland');\r\n          break;\r\n        case 'gu':\r\n          nearbyRegions.push('vastra_gotaland', 'halland', 'varmland');\r\n          break;\r\n      }\r\n      \r\n      // Fördela sökande över regioner\r\n      mockRegions.forEach(region => {\r\n        let percentage: number;\r\n        \r\n        if (nearbyRegions.includes(region.id)) {\r\n          // Högre procent från närliggande regioner (10-25%)\r\n          percentage = 10 + Math.random() * 15;\r\n        } else {\r\n          // Lägre procent från andra regioner (1-5%)\r\n          percentage = 1 + Math.random() * 4;\r\n        }\r\n        \r\n        // Justera för att säkerställa att summan blir 100%\r\n        totalPercentage += percentage;\r\n        \r\n        // Simulera antalet sökande baserat på procent\r\n        // Anta att vi har totalt 1000-3000 sökande per år\r\n        const totalApplicants = 1000 + Math.floor(Math.random() * 2000);\r\n        const applicantCount = Math.floor((percentage / 100) * totalApplicants);\r\n        \r\n        regionData.push({\r\n          regionId: region.id,\r\n          regionName: region.name,\r\n          applicantCount,\r\n          percentage\r\n        });\r\n      });\r\n      \r\n      // Normalisera procentandelarna så att summan blir 100%\r\n      regionData.forEach(data => {\r\n        data.percentage = (data.percentage / totalPercentage) * 100;\r\n      });\r\n      \r\n      // Sortera efter antal sökande (fallande)\r\n      regionData.sort((a, b) => b.applicantCount - a.applicantCount);\r\n      \r\n      distributions.push({\r\n        universityId: university.id,\r\n        year,\r\n        regionData\r\n      });\r\n    }\r\n  });\r\n  \r\n  return distributions;\r\n};\r\n\r\n// Generera simulerad könsfördelning\r\nconst generateMockGenderDistribution = (): GenderDistribution[] => {\r\n  const distributions: GenderDistribution[] = [];\r\n  \r\n  // För varje lärosäte\r\n  mockUniversities.forEach(university => {\r\n    // För varje år\r\n    for (let year = 2010; year <= 2023; year++) {\r\n      // För varje program\r\n      const programs = [\r\n        { id: `${university.id}-cs`, name: 'Datavetenskap', type: 'cs' },\r\n        { id: `${university.id}-eng`, name: 'Civilingenjör', type: 'eng' },\r\n        { id: `${university.id}-med`, name: 'Läkarprogrammet', type: 'med' },\r\n      ];\r\n      \r\n      // Lägg till en total för hela lärosätet\r\n      const totalApplicants = 1500 + Math.floor(Math.random() * 1000) + (year - 2010) * 100;\r\n      const totalAccepted = Math.floor(totalApplicants * (0.2 + Math.random() * 0.1));\r\n      \r\n      // Beräkna genomsnittlig könsfördelning för lärosätet\r\n      // Anta en gradvis förändring mot jämnare könsfördelning över tid\r\n      const yearFactor = (year - 2010) * 0.005; // Små förändringar per år\r\n      \r\n      // Genomsnittlig könsfördelning för lärosätet\r\n      let maleBias = 0.55 - yearFactor; // Startar med 55% män, minskar något över tid\r\n      let femaleBias = 0.43 + yearFactor; // Startar med 43% kvinnor, ökar något över tid\r\n      const otherBias = 0.02; // Konstant 2% övriga\r\n      \r\n      // Justera för att säkerställa att summan blir 100%\r\n      const totalBias = maleBias + femaleBias + otherBias;\r\n      maleBias = maleBias / totalBias;\r\n      femaleBias = femaleBias / totalBias;\r\n      \r\n      // Lägg till total för lärosätet\r\n      distributions.push({\r\n        universityId: university.id,\r\n        year,\r\n        maleApplicants: Math.floor(totalApplicants * maleBias),\r\n        femaleApplicants: Math.floor(totalApplicants * femaleBias),\r\n        otherApplicants: Math.floor(totalApplicants * otherBias),\r\n        maleAccepted: Math.floor(totalAccepted * maleBias),\r\n        femaleAccepted: Math.floor(totalAccepted * femaleBias),\r\n        otherAccepted: Math.floor(totalAccepted * otherBias)\r\n      });\r\n      \r\n      // Lägg till för varje program\r\n      programs.forEach(program => {\r\n        const programApplicants = 400 + Math.floor(Math.random() * 300) + (year - 2010) * 30;\r\n        const programAccepted = Math.floor(programApplicants * (0.15 + Math.random() * 0.15));\r\n        \r\n        // Hämta programmets typiska könsfördelning\r\n        const genderBias = programGenderBias[program.type];\r\n        \r\n        // Justera för förändringar över tid (gradvis jämnare fördelning)\r\n        let maleRatio = genderBias.male - yearFactor * (genderBias.male > 0.5 ? 1 : -1);\r\n        let femaleRatio = genderBias.female + yearFactor * (genderBias.female < 0.5 ? 1 : -1);\r\n        const otherRatio = genderBias.other;\r\n        \r\n        // Normalisera för att säkerställa att summan blir 100%\r\n        const totalRatio = maleRatio + femaleRatio + otherRatio;\r\n        maleRatio = maleRatio / totalRatio;\r\n        femaleRatio = femaleRatio / totalRatio;\r\n        \r\n        distributions.push({\r\n          universityId: university.id,\r\n          year,\r\n          programId: program.id,\r\n          programName: program.name,\r\n          maleApplicants: Math.floor(programApplicants * maleRatio),\r\n          femaleApplicants: Math.floor(programApplicants * femaleRatio),\r\n          otherApplicants: Math.floor(programApplicants * otherRatio),\r\n          maleAccepted: Math.floor(programAccepted * maleRatio),\r\n          femaleAccepted: Math.floor(programAccepted * femaleRatio),\r\n          otherAccepted: Math.floor(programAccepted * otherRatio)\r\n        });\r\n      });\r\n    }\r\n  });\r\n  \r\n  return distributions;\r\n};\r\n\r\nconst mockStatistics = generateMockStatistics();\r\nconst mockGeographicDistributions = generateMockGeographicDistribution();\r\nconst mockGenderDistributions = generateMockGenderDistribution();\r\n\r\n// Hämta alla lärosäten\r\nexport const getUniversities = async (): Promise<University[]> => {\r\n  try {\r\n    // Försök hämta från API först\r\n    const response = await axios.get<University[]>(`${API_BASE_URL}/universities`);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.warn('Kunde inte hämta lärosäten från API, använder mockdata istället', error);\r\n    // Fallback till mockdata om API-anropet misslyckas\r\n    return Promise.resolve(mockUniversities);\r\n  }\r\n};\r\n\r\n// Hämta alla regioner\r\nexport const getRegions = async (): Promise<Region[]> => {\r\n  try {\r\n    const response = await axios.get<Region[]>(`${API_BASE_URL}/regions`);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.warn('Kunde inte hämta regioner från API, använder mockdata istället', error);\r\n    return Promise.resolve(mockRegions);\r\n  }\r\n};\r\n\r\n// Hämta statistik baserat på filter\r\nexport const getStatistics = async (filter: StatisticsFilter): Promise<ProgramStatistics[]> => {\r\n  try {\r\n    const response = await axios.get<ProgramStatistics[]>(`${API_BASE_URL}/statistics`, { \r\n      params: filter \r\n    });\r\n    return response.data;\r\n  } catch (error) {\r\n    console.warn('Kunde inte hämta statistik från API, använder mockdata istället', error);\r\n    \r\n    // Fallback till mockdata\r\n    let filteredStats = [...mockStatistics];\r\n    \r\n    if (filter.universityId) {\r\n      filteredStats = filteredStats.filter(stat => stat.universityId === filter.universityId);\r\n    }\r\n    \r\n    if (filter.fromYear) {\r\n      filteredStats = filteredStats.filter(stat => stat.year >= filter.fromYear!);\r\n    }\r\n    \r\n    if (filter.toYear) {\r\n      filteredStats = filteredStats.filter(stat => stat.year <= filter.toYear!);\r\n    }\r\n    \r\n    if (filter.programId) {\r\n      filteredStats = filteredStats.filter(stat => stat.id.startsWith(filter.programId!));\r\n    }\r\n    \r\n    return Promise.resolve(filteredStats);\r\n  }\r\n};\r\n\r\n// Hämta aggregerad statistik för ett lärosäte\r\nexport const getUniversityStatistics = async (universityId: string): Promise<UniversityStatistics[]> => {\r\n  try {\r\n    const response = await axios.get<UniversityStatistics[]>(`${API_BASE_URL}/universities/${universityId}/statistics`);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.warn('Kunde inte hämta universitetsstatistik från API, använder mockdata istället', error);\r\n    \r\n    // Fallback till mockdata\r\n    const stats = await getStatistics({ universityId });\r\n    \r\n    // Gruppera efter år\r\n    const yearGroups: { [key: number]: ProgramStatistics[] } = {};\r\n    stats.forEach(stat => {\r\n      if (!yearGroups[stat.year]) {\r\n        yearGroups[stat.year] = [];\r\n      }\r\n      yearGroups[stat.year].push(stat);\r\n    });\r\n    \r\n    // Skapa aggregerad statistik per år\r\n    const universityStats: UniversityStatistics[] = Object.keys(yearGroups).map(yearStr => {\r\n      const year = parseInt(yearStr);\r\n      const programs = yearGroups[year];\r\n      \r\n      const totalApplicants = programs.reduce((sum, prog) => sum + prog.applicants, 0);\r\n      const totalAcceptedStudents = programs.reduce((sum, prog) => sum + prog.acceptedStudents, 0);\r\n      \r\n      return {\r\n        universityId,\r\n        year,\r\n        totalApplicants,\r\n        totalAcceptedStudents,\r\n        programs\r\n      };\r\n    });\r\n    \r\n    return universityStats.sort((a, b) => a.year - b.year);\r\n  }\r\n};\r\n\r\n// Hämta geografisk fördelning för ett lärosäte\r\nexport const getGeographicDistribution = async (universityId: string, year?: number): Promise<GeographicDistribution[]> => {\r\n  try {\r\n    const params = year ? { year } : {};\r\n    const response = await axios.get<GeographicDistribution[]>(\r\n      `${API_BASE_URL}/universities/${universityId}/geographic-distribution`,\r\n      { params }\r\n    );\r\n    return response.data;\r\n  } catch (error) {\r\n    console.warn('Kunde inte hämta geografisk fördelning från API, använder mockdata istället', error);\r\n    \r\n    // Fallback till mockdata\r\n    let filteredDistributions = [...mockGeographicDistributions].filter(\r\n      dist => dist.universityId === universityId\r\n    );\r\n    \r\n    if (year) {\r\n      filteredDistributions = filteredDistributions.filter(dist => dist.year === year);\r\n    }\r\n    \r\n    return Promise.resolve(filteredDistributions.sort((a, b) => a.year - b.year));\r\n  }\r\n};\r\n\r\n// Hämta könsfördelning för ett lärosäte\r\nexport const getGenderDistribution = async (\r\n  universityId: string, \r\n  year?: number, \r\n  programId?: string\r\n): Promise<GenderDistribution[]> => {\r\n  try {\r\n    const params = { year, programId };\r\n    const response = await axios.get<GenderDistribution[]>(\r\n      `${API_BASE_URL}/universities/${universityId}/gender-distribution`,\r\n      { params }\r\n    );\r\n    return response.data;\r\n  } catch (error) {\r\n    console.warn('Kunde inte hämta könsfördelning från API, använder mockdata istället', error);\r\n    \r\n    // Fallback till mockdata\r\n    let filteredDistributions = [...mockGenderDistributions].filter(\r\n      dist => dist.universityId === universityId\r\n    );\r\n    \r\n    if (year) {\r\n      filteredDistributions = filteredDistributions.filter(dist => dist.year === year);\r\n    }\r\n    \r\n    if (programId) {\r\n      filteredDistributions = filteredDistributions.filter(dist => dist.programId === programId);\r\n    }\r\n    \r\n    return Promise.resolve(filteredDistributions.sort((a, b) => {\r\n      // Sortera först efter år\r\n      if (a.year !== b.year) return a.year - b.year;\r\n      \r\n      // Sedan sortera så att totalen för lärosätet kommer först\r\n      if (!a.programId && b.programId) return -1;\r\n      if (a.programId && !b.programId) return 1;\r\n      \r\n      // Slutligen sortera program alfabetiskt\r\n      if (a.programName && b.programName) {\r\n        return a.programName.localeCompare(b.programName);\r\n      }\r\n      \r\n      return 0;\r\n    }));\r\n  }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}