{"ast":null,"code":"// Simulerad data för demonstration\nconst mockUniversities = [{\n  id: 'kth',\n  name: 'Kungliga Tekniska Högskolan'\n}, {\n  id: 'su',\n  name: 'Stockholms Universitet'\n}, {\n  id: 'uu',\n  name: 'Uppsala Universitet'\n}, {\n  id: 'lu',\n  name: 'Lunds Universitet'\n}, {\n  id: 'gu',\n  name: 'Göteborgs Universitet'\n}];\n\n// Svenska regioner\nconst mockRegions = [{\n  id: 'stockholm',\n  name: 'Stockholm'\n}, {\n  id: 'uppsala',\n  name: 'Uppsala'\n}, {\n  id: 'skane',\n  name: 'Skåne'\n}, {\n  id: 'vastra_gotaland',\n  name: 'Västra Götaland'\n}, {\n  id: 'ostergotland',\n  name: 'Östergötland'\n}, {\n  id: 'norrbotten',\n  name: 'Norrbotten'\n}, {\n  id: 'vasterbotten',\n  name: 'Västerbotten'\n}, {\n  id: 'jamtland',\n  name: 'Jämtland'\n}, {\n  id: 'dalarna',\n  name: 'Dalarna'\n}, {\n  id: 'orebro',\n  name: 'Örebro'\n}, {\n  id: 'vastmanland',\n  name: 'Västmanland'\n}, {\n  id: 'sodermanland',\n  name: 'Södermanland'\n}, {\n  id: 'gavleborg',\n  name: 'Gävleborg'\n}, {\n  id: 'varmland',\n  name: 'Värmland'\n}, {\n  id: 'jonkoping',\n  name: 'Jönköping'\n}, {\n  id: 'kalmar',\n  name: 'Kalmar'\n}, {\n  id: 'kronoberg',\n  name: 'Kronoberg'\n}, {\n  id: 'blekinge',\n  name: 'Blekinge'\n}, {\n  id: 'halland',\n  name: 'Halland'\n}, {\n  id: 'gotland',\n  name: 'Gotland'\n}, {\n  id: 'vasternorrland',\n  name: 'Västernorrland'\n}];\n\n// Generera simulerad statistik för demonstration\nconst generateMockStatistics = () => {\n  const statistics = [];\n  mockUniversities.forEach(university => {\n    const programs = [{\n      id: `${university.id}-cs`,\n      name: 'Datavetenskap'\n    }, {\n      id: `${university.id}-eng`,\n      name: 'Civilingenjör'\n    }, {\n      id: `${university.id}-med`,\n      name: 'Läkarprogrammet'\n    }];\n    programs.forEach(program => {\n      for (let year = 2015; year <= 2023; year++) {\n        // Simulera en trend med ökande antal sökande\n        const baseApplicants = 500 + Math.floor(Math.random() * 500);\n        const yearFactor = (year - 2015) * 50;\n        const randomFactor = Math.floor(Math.random() * 200) - 100;\n        const applicants = baseApplicants + yearFactor + randomFactor;\n        const acceptedStudents = Math.floor(applicants * (0.1 + Math.random() * 0.2));\n        const firstHandApplicants = Math.floor(applicants * (0.4 + Math.random() * 0.3));\n        statistics.push({\n          id: `${program.id}-${year}`,\n          name: program.name,\n          universityId: university.id,\n          year,\n          applicants,\n          acceptedStudents,\n          firstHandApplicants\n        });\n      }\n    });\n  });\n  return statistics;\n};\n\n// Generera simulerad geografisk fördelning\nconst generateMockGeographicDistribution = () => {\n  const distributions = [];\n  mockUniversities.forEach(university => {\n    for (let year = 2015; year <= 2023; year++) {\n      // Skapa en fördelning baserad på lärosätets geografiska läge\n      // Högre procent från närliggande regioner\n      const regionData = [];\n      let totalPercentage = 0;\n\n      // Bestäm vilka regioner som är \"nära\" lärosätet\n      const nearbyRegions = [];\n      switch (university.id) {\n        case 'kth':\n        case 'su':\n          nearbyRegions.push('stockholm', 'uppsala', 'sodermanland');\n          break;\n        case 'uu':\n          nearbyRegions.push('uppsala', 'stockholm', 'vastmanland');\n          break;\n        case 'lu':\n          nearbyRegions.push('skane', 'blekinge', 'halland');\n          break;\n        case 'gu':\n          nearbyRegions.push('vastra_gotaland', 'halland', 'varmland');\n          break;\n      }\n\n      // Fördela sökande över regioner\n      mockRegions.forEach(region => {\n        let percentage;\n        if (nearbyRegions.includes(region.id)) {\n          // Högre procent från närliggande regioner (10-25%)\n          percentage = 10 + Math.random() * 15;\n        } else {\n          // Lägre procent från andra regioner (1-5%)\n          percentage = 1 + Math.random() * 4;\n        }\n\n        // Justera för att säkerställa att summan blir 100%\n        totalPercentage += percentage;\n\n        // Simulera antalet sökande baserat på procent\n        // Anta att vi har totalt 1000-3000 sökande per år\n        const totalApplicants = 1000 + Math.floor(Math.random() * 2000);\n        const applicantCount = Math.floor(percentage / 100 * totalApplicants);\n        regionData.push({\n          regionId: region.id,\n          regionName: region.name,\n          applicantCount,\n          percentage\n        });\n      });\n\n      // Normalisera procentandelarna så att summan blir 100%\n      regionData.forEach(data => {\n        data.percentage = data.percentage / totalPercentage * 100;\n      });\n\n      // Sortera efter antal sökande (fallande)\n      regionData.sort((a, b) => b.applicantCount - a.applicantCount);\n      distributions.push({\n        universityId: university.id,\n        year,\n        regionData\n      });\n    }\n  });\n  return distributions;\n};\nconst mockStatistics = generateMockStatistics();\nconst mockGeographicDistributions = generateMockGeographicDistribution();\n\n// Hämta alla lärosäten\nexport const getUniversities = async () => {\n  // I en riktig applikation skulle vi hämta data från en API\n  // return axios.get<University[]>('/api/universities').then(response => response.data);\n\n  return Promise.resolve(mockUniversities);\n};\n\n// Hämta alla regioner\nexport const getRegions = async () => {\n  return Promise.resolve(mockRegions);\n};\n\n// Hämta statistik baserat på filter\nexport const getStatistics = async filter => {\n  // I en riktig applikation skulle vi hämta data från en API\n  // return axios.get<ProgramStatistics[]>('/api/statistics', { params: filter }).then(response => response.data);\n\n  let filteredStats = [...mockStatistics];\n  if (filter.universityId) {\n    filteredStats = filteredStats.filter(stat => stat.universityId === filter.universityId);\n  }\n  if (filter.fromYear) {\n    filteredStats = filteredStats.filter(stat => stat.year >= filter.fromYear);\n  }\n  if (filter.toYear) {\n    filteredStats = filteredStats.filter(stat => stat.year <= filter.toYear);\n  }\n  if (filter.programId) {\n    filteredStats = filteredStats.filter(stat => stat.id.startsWith(filter.programId));\n  }\n  return Promise.resolve(filteredStats);\n};\n\n// Hämta aggregerad statistik för ett lärosäte\nexport const getUniversityStatistics = async universityId => {\n  const stats = await getStatistics({\n    universityId\n  });\n\n  // Gruppera efter år\n  const yearGroups = {};\n  stats.forEach(stat => {\n    if (!yearGroups[stat.year]) {\n      yearGroups[stat.year] = [];\n    }\n    yearGroups[stat.year].push(stat);\n  });\n\n  // Skapa aggregerad statistik per år\n  const universityStats = Object.keys(yearGroups).map(yearStr => {\n    const year = parseInt(yearStr);\n    const programs = yearGroups[year];\n    const totalApplicants = programs.reduce((sum, prog) => sum + prog.applicants, 0);\n    const totalAcceptedStudents = programs.reduce((sum, prog) => sum + prog.acceptedStudents, 0);\n    return {\n      universityId,\n      year,\n      totalApplicants,\n      totalAcceptedStudents,\n      programs\n    };\n  });\n  return universityStats.sort((a, b) => a.year - b.year);\n};\n\n// Hämta geografisk fördelning för ett lärosäte\nexport const getGeographicDistribution = async (universityId, year) => {\n  let filteredDistributions = [...mockGeographicDistributions].filter(dist => dist.universityId === universityId);\n  if (year) {\n    filteredDistributions = filteredDistributions.filter(dist => dist.year === year);\n  }\n  return Promise.resolve(filteredDistributions.sort((a, b) => a.year - b.year));\n};","map":{"version":3,"names":["mockUniversities","id","name","mockRegions","generateMockStatistics","statistics","forEach","university","programs","program","year","baseApplicants","Math","floor","random","yearFactor","randomFactor","applicants","acceptedStudents","firstHandApplicants","push","universityId","generateMockGeographicDistribution","distributions","regionData","totalPercentage","nearbyRegions","region","percentage","includes","totalApplicants","applicantCount","regionId","regionName","data","sort","a","b","mockStatistics","mockGeographicDistributions","getUniversities","Promise","resolve","getRegions","getStatistics","filter","filteredStats","stat","fromYear","toYear","programId","startsWith","getUniversityStatistics","stats","yearGroups","universityStats","Object","keys","map","yearStr","parseInt","reduce","sum","prog","totalAcceptedStudents","getGeographicDistribution","filteredDistributions","dist"],"sources":["C:/Users/saak0033/source/repos/IP/src/services/statisticsService.ts"],"sourcesContent":["import axios from 'axios';\r\nimport { University, ProgramStatistics, UniversityStatistics, StatisticsFilter, GeographicDistribution, RegionData, Region } from '../models/types';\r\n\r\n// Simulerad data för demonstration\r\nconst mockUniversities: University[] = [\r\n  { id: 'kth', name: 'Kungliga Tekniska Högskolan' },\r\n  { id: 'su', name: 'Stockholms Universitet' },\r\n  { id: 'uu', name: 'Uppsala Universitet' },\r\n  { id: 'lu', name: 'Lunds Universitet' },\r\n  { id: 'gu', name: 'Göteborgs Universitet' },\r\n];\r\n\r\n// Svenska regioner\r\nconst mockRegions: Region[] = [\r\n  { id: 'stockholm', name: 'Stockholm' },\r\n  { id: 'uppsala', name: 'Uppsala' },\r\n  { id: 'skane', name: 'Skåne' },\r\n  { id: 'vastra_gotaland', name: 'Västra Götaland' },\r\n  { id: 'ostergotland', name: 'Östergötland' },\r\n  { id: 'norrbotten', name: 'Norrbotten' },\r\n  { id: 'vasterbotten', name: 'Västerbotten' },\r\n  { id: 'jamtland', name: 'Jämtland' },\r\n  { id: 'dalarna', name: 'Dalarna' },\r\n  { id: 'orebro', name: 'Örebro' },\r\n  { id: 'vastmanland', name: 'Västmanland' },\r\n  { id: 'sodermanland', name: 'Södermanland' },\r\n  { id: 'gavleborg', name: 'Gävleborg' },\r\n  { id: 'varmland', name: 'Värmland' },\r\n  { id: 'jonkoping', name: 'Jönköping' },\r\n  { id: 'kalmar', name: 'Kalmar' },\r\n  { id: 'kronoberg', name: 'Kronoberg' },\r\n  { id: 'blekinge', name: 'Blekinge' },\r\n  { id: 'halland', name: 'Halland' },\r\n  { id: 'gotland', name: 'Gotland' },\r\n  { id: 'vasternorrland', name: 'Västernorrland' },\r\n];\r\n\r\n// Generera simulerad statistik för demonstration\r\nconst generateMockStatistics = (): ProgramStatistics[] => {\r\n  const statistics: ProgramStatistics[] = [];\r\n  \r\n  mockUniversities.forEach(university => {\r\n    const programs = [\r\n      { id: `${university.id}-cs`, name: 'Datavetenskap' },\r\n      { id: `${university.id}-eng`, name: 'Civilingenjör' },\r\n      { id: `${university.id}-med`, name: 'Läkarprogrammet' },\r\n    ];\r\n    \r\n    programs.forEach(program => {\r\n      for (let year = 2015; year <= 2023; year++) {\r\n        // Simulera en trend med ökande antal sökande\r\n        const baseApplicants = 500 + Math.floor(Math.random() * 500);\r\n        const yearFactor = (year - 2015) * 50;\r\n        const randomFactor = Math.floor(Math.random() * 200) - 100;\r\n        \r\n        const applicants = baseApplicants + yearFactor + randomFactor;\r\n        const acceptedStudents = Math.floor(applicants * (0.1 + Math.random() * 0.2));\r\n        const firstHandApplicants = Math.floor(applicants * (0.4 + Math.random() * 0.3));\r\n        \r\n        statistics.push({\r\n          id: `${program.id}-${year}`,\r\n          name: program.name,\r\n          universityId: university.id,\r\n          year,\r\n          applicants,\r\n          acceptedStudents,\r\n          firstHandApplicants\r\n        });\r\n      }\r\n    });\r\n  });\r\n  \r\n  return statistics;\r\n};\r\n\r\n// Generera simulerad geografisk fördelning\r\nconst generateMockGeographicDistribution = (): GeographicDistribution[] => {\r\n  const distributions: GeographicDistribution[] = [];\r\n  \r\n  mockUniversities.forEach(university => {\r\n    for (let year = 2015; year <= 2023; year++) {\r\n      // Skapa en fördelning baserad på lärosätets geografiska läge\r\n      // Högre procent från närliggande regioner\r\n      const regionData: RegionData[] = [];\r\n      let totalPercentage = 0;\r\n      \r\n      // Bestäm vilka regioner som är \"nära\" lärosätet\r\n      const nearbyRegions: string[] = [];\r\n      switch (university.id) {\r\n        case 'kth':\r\n        case 'su':\r\n          nearbyRegions.push('stockholm', 'uppsala', 'sodermanland');\r\n          break;\r\n        case 'uu':\r\n          nearbyRegions.push('uppsala', 'stockholm', 'vastmanland');\r\n          break;\r\n        case 'lu':\r\n          nearbyRegions.push('skane', 'blekinge', 'halland');\r\n          break;\r\n        case 'gu':\r\n          nearbyRegions.push('vastra_gotaland', 'halland', 'varmland');\r\n          break;\r\n      }\r\n      \r\n      // Fördela sökande över regioner\r\n      mockRegions.forEach(region => {\r\n        let percentage: number;\r\n        \r\n        if (nearbyRegions.includes(region.id)) {\r\n          // Högre procent från närliggande regioner (10-25%)\r\n          percentage = 10 + Math.random() * 15;\r\n        } else {\r\n          // Lägre procent från andra regioner (1-5%)\r\n          percentage = 1 + Math.random() * 4;\r\n        }\r\n        \r\n        // Justera för att säkerställa att summan blir 100%\r\n        totalPercentage += percentage;\r\n        \r\n        // Simulera antalet sökande baserat på procent\r\n        // Anta att vi har totalt 1000-3000 sökande per år\r\n        const totalApplicants = 1000 + Math.floor(Math.random() * 2000);\r\n        const applicantCount = Math.floor((percentage / 100) * totalApplicants);\r\n        \r\n        regionData.push({\r\n          regionId: region.id,\r\n          regionName: region.name,\r\n          applicantCount,\r\n          percentage\r\n        });\r\n      });\r\n      \r\n      // Normalisera procentandelarna så att summan blir 100%\r\n      regionData.forEach(data => {\r\n        data.percentage = (data.percentage / totalPercentage) * 100;\r\n      });\r\n      \r\n      // Sortera efter antal sökande (fallande)\r\n      regionData.sort((a, b) => b.applicantCount - a.applicantCount);\r\n      \r\n      distributions.push({\r\n        universityId: university.id,\r\n        year,\r\n        regionData\r\n      });\r\n    }\r\n  });\r\n  \r\n  return distributions;\r\n};\r\n\r\nconst mockStatistics = generateMockStatistics();\r\nconst mockGeographicDistributions = generateMockGeographicDistribution();\r\n\r\n// Hämta alla lärosäten\r\nexport const getUniversities = async (): Promise<University[]> => {\r\n  // I en riktig applikation skulle vi hämta data från en API\r\n  // return axios.get<University[]>('/api/universities').then(response => response.data);\r\n  \r\n  return Promise.resolve(mockUniversities);\r\n};\r\n\r\n// Hämta alla regioner\r\nexport const getRegions = async (): Promise<Region[]> => {\r\n  return Promise.resolve(mockRegions);\r\n};\r\n\r\n// Hämta statistik baserat på filter\r\nexport const getStatistics = async (filter: StatisticsFilter): Promise<ProgramStatistics[]> => {\r\n  // I en riktig applikation skulle vi hämta data från en API\r\n  // return axios.get<ProgramStatistics[]>('/api/statistics', { params: filter }).then(response => response.data);\r\n  \r\n  let filteredStats = [...mockStatistics];\r\n  \r\n  if (filter.universityId) {\r\n    filteredStats = filteredStats.filter(stat => stat.universityId === filter.universityId);\r\n  }\r\n  \r\n  if (filter.fromYear) {\r\n    filteredStats = filteredStats.filter(stat => stat.year >= filter.fromYear!);\r\n  }\r\n  \r\n  if (filter.toYear) {\r\n    filteredStats = filteredStats.filter(stat => stat.year <= filter.toYear!);\r\n  }\r\n  \r\n  if (filter.programId) {\r\n    filteredStats = filteredStats.filter(stat => stat.id.startsWith(filter.programId!));\r\n  }\r\n  \r\n  return Promise.resolve(filteredStats);\r\n};\r\n\r\n// Hämta aggregerad statistik för ett lärosäte\r\nexport const getUniversityStatistics = async (universityId: string): Promise<UniversityStatistics[]> => {\r\n  const stats = await getStatistics({ universityId });\r\n  \r\n  // Gruppera efter år\r\n  const yearGroups: { [key: number]: ProgramStatistics[] } = {};\r\n  stats.forEach(stat => {\r\n    if (!yearGroups[stat.year]) {\r\n      yearGroups[stat.year] = [];\r\n    }\r\n    yearGroups[stat.year].push(stat);\r\n  });\r\n  \r\n  // Skapa aggregerad statistik per år\r\n  const universityStats: UniversityStatistics[] = Object.keys(yearGroups).map(yearStr => {\r\n    const year = parseInt(yearStr);\r\n    const programs = yearGroups[year];\r\n    \r\n    const totalApplicants = programs.reduce((sum, prog) => sum + prog.applicants, 0);\r\n    const totalAcceptedStudents = programs.reduce((sum, prog) => sum + prog.acceptedStudents, 0);\r\n    \r\n    return {\r\n      universityId,\r\n      year,\r\n      totalApplicants,\r\n      totalAcceptedStudents,\r\n      programs\r\n    };\r\n  });\r\n  \r\n  return universityStats.sort((a, b) => a.year - b.year);\r\n};\r\n\r\n// Hämta geografisk fördelning för ett lärosäte\r\nexport const getGeographicDistribution = async (universityId: string, year?: number): Promise<GeographicDistribution[]> => {\r\n  let filteredDistributions = [...mockGeographicDistributions].filter(\r\n    dist => dist.universityId === universityId\r\n  );\r\n  \r\n  if (year) {\r\n    filteredDistributions = filteredDistributions.filter(dist => dist.year === year);\r\n  }\r\n  \r\n  return Promise.resolve(filteredDistributions.sort((a, b) => a.year - b.year));\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}