{"ast":null,"code":"// Simulerad data för demonstration\nconst mockUniversities = [{\n  id: 'kth',\n  name: 'Kungliga Tekniska Högskolan'\n}, {\n  id: 'su',\n  name: 'Stockholms Universitet'\n}, {\n  id: 'uu',\n  name: 'Uppsala Universitet'\n}, {\n  id: 'lu',\n  name: 'Lunds Universitet'\n}, {\n  id: 'gu',\n  name: 'Göteborgs Universitet'\n}];\n\n// Svenska regioner\nconst mockRegions = [{\n  id: 'stockholm',\n  name: 'Stockholm'\n}, {\n  id: 'uppsala',\n  name: 'Uppsala'\n}, {\n  id: 'skane',\n  name: 'Skåne'\n}, {\n  id: 'vastra_gotaland',\n  name: 'Västra Götaland'\n}, {\n  id: 'ostergotland',\n  name: 'Östergötland'\n}, {\n  id: 'norrbotten',\n  name: 'Norrbotten'\n}, {\n  id: 'vasterbotten',\n  name: 'Västerbotten'\n}, {\n  id: 'jamtland',\n  name: 'Jämtland'\n}, {\n  id: 'dalarna',\n  name: 'Dalarna'\n}, {\n  id: 'orebro',\n  name: 'Örebro'\n}, {\n  id: 'vastmanland',\n  name: 'Västmanland'\n}, {\n  id: 'sodermanland',\n  name: 'Södermanland'\n}, {\n  id: 'gavleborg',\n  name: 'Gävleborg'\n}, {\n  id: 'varmland',\n  name: 'Värmland'\n}, {\n  id: 'jonkoping',\n  name: 'Jönköping'\n}, {\n  id: 'kalmar',\n  name: 'Kalmar'\n}, {\n  id: 'kronoberg',\n  name: 'Kronoberg'\n}, {\n  id: 'blekinge',\n  name: 'Blekinge'\n}, {\n  id: 'halland',\n  name: 'Halland'\n}, {\n  id: 'gotland',\n  name: 'Gotland'\n}, {\n  id: 'vasternorrland',\n  name: 'Västernorrland'\n}];\n\n// Program med typisk könsfördelning\nconst programGenderBias = {\n  'cs': {\n    male: 0.75,\n    female: 0.23,\n    other: 0.02\n  },\n  // Datavetenskap - mansdominerad\n  'eng': {\n    male: 0.65,\n    female: 0.33,\n    other: 0.02\n  },\n  // Civilingenjör - mansdominerad\n  'med': {\n    male: 0.35,\n    female: 0.63,\n    other: 0.02\n  } // Läkarprogrammet - kvinnodominerad\n};\n\n// Generera simulerad statistik för demonstration\nconst generateMockStatistics = () => {\n  const statistics = [];\n  mockUniversities.forEach(university => {\n    const programs = [{\n      id: `${university.id}-cs`,\n      name: 'Datavetenskap'\n    }, {\n      id: `${university.id}-eng`,\n      name: 'Civilingenjör'\n    }, {\n      id: `${university.id}-med`,\n      name: 'Läkarprogrammet'\n    }];\n    programs.forEach(program => {\n      for (let year = 2015; year <= 2023; year++) {\n        // Simulera en trend med ökande antal sökande\n        const baseApplicants = 500 + Math.floor(Math.random() * 500);\n        const yearFactor = (year - 2015) * 50;\n        const randomFactor = Math.floor(Math.random() * 200) - 100;\n        const applicants = baseApplicants + yearFactor + randomFactor;\n        const acceptedStudents = Math.floor(applicants * (0.1 + Math.random() * 0.2));\n        const firstHandApplicants = Math.floor(applicants * (0.4 + Math.random() * 0.3));\n        statistics.push({\n          id: `${program.id}-${year}`,\n          name: program.name,\n          universityId: university.id,\n          year,\n          applicants,\n          acceptedStudents,\n          firstHandApplicants\n        });\n      }\n    });\n  });\n  return statistics;\n};\n\n// Generera simulerad geografisk fördelning\nconst generateMockGeographicDistribution = () => {\n  const distributions = [];\n  mockUniversities.forEach(university => {\n    for (let year = 2015; year <= 2023; year++) {\n      // Skapa en fördelning baserad på lärosätets geografiska läge\n      // Högre procent från närliggande regioner\n      const regionData = [];\n      let totalPercentage = 0;\n\n      // Bestäm vilka regioner som är \"nära\" lärosätet\n      const nearbyRegions = [];\n      switch (university.id) {\n        case 'kth':\n        case 'su':\n          nearbyRegions.push('stockholm', 'uppsala', 'sodermanland');\n          break;\n        case 'uu':\n          nearbyRegions.push('uppsala', 'stockholm', 'vastmanland');\n          break;\n        case 'lu':\n          nearbyRegions.push('skane', 'blekinge', 'halland');\n          break;\n        case 'gu':\n          nearbyRegions.push('vastra_gotaland', 'halland', 'varmland');\n          break;\n      }\n\n      // Fördela sökande över regioner\n      mockRegions.forEach(region => {\n        let percentage;\n        if (nearbyRegions.includes(region.id)) {\n          // Högre procent från närliggande regioner (10-25%)\n          percentage = 10 + Math.random() * 15;\n        } else {\n          // Lägre procent från andra regioner (1-5%)\n          percentage = 1 + Math.random() * 4;\n        }\n\n        // Justera för att säkerställa att summan blir 100%\n        totalPercentage += percentage;\n\n        // Simulera antalet sökande baserat på procent\n        // Anta att vi har totalt 1000-3000 sökande per år\n        const totalApplicants = 1000 + Math.floor(Math.random() * 2000);\n        const applicantCount = Math.floor(percentage / 100 * totalApplicants);\n        regionData.push({\n          regionId: region.id,\n          regionName: region.name,\n          applicantCount,\n          percentage\n        });\n      });\n\n      // Normalisera procentandelarna så att summan blir 100%\n      regionData.forEach(data => {\n        data.percentage = data.percentage / totalPercentage * 100;\n      });\n\n      // Sortera efter antal sökande (fallande)\n      regionData.sort((a, b) => b.applicantCount - a.applicantCount);\n      distributions.push({\n        universityId: university.id,\n        year,\n        regionData\n      });\n    }\n  });\n  return distributions;\n};\n\n// Generera simulerad könsfördelning\nconst generateMockGenderDistribution = () => {\n  const distributions = [];\n\n  // För varje lärosäte\n  mockUniversities.forEach(university => {\n    // För varje år\n    for (let year = 2015; year <= 2023; year++) {\n      // För varje program\n      const programs = [{\n        id: `${university.id}-cs`,\n        name: 'Datavetenskap',\n        type: 'cs'\n      }, {\n        id: `${university.id}-eng`,\n        name: 'Civilingenjör',\n        type: 'eng'\n      }, {\n        id: `${university.id}-med`,\n        name: 'Läkarprogrammet',\n        type: 'med'\n      }];\n\n      // Lägg till en total för hela lärosätet\n      const totalApplicants = 1500 + Math.floor(Math.random() * 1000) + (year - 2015) * 100;\n      const totalAccepted = Math.floor(totalApplicants * (0.2 + Math.random() * 0.1));\n\n      // Beräkna genomsnittlig könsfördelning för lärosätet\n      // Anta en gradvis förändring mot jämnare könsfördelning över tid\n      const yearFactor = (year - 2015) * 0.005; // Små förändringar per år\n\n      // Genomsnittlig könsfördelning för lärosätet\n      let maleBias = 0.55 - yearFactor; // Startar med 55% män, minskar något över tid\n      let femaleBias = 0.43 + yearFactor; // Startar med 43% kvinnor, ökar något över tid\n      const otherBias = 0.02; // Konstant 2% övriga\n\n      // Justera för att säkerställa att summan blir 100%\n      const totalBias = maleBias + femaleBias + otherBias;\n      maleBias = maleBias / totalBias;\n      femaleBias = femaleBias / totalBias;\n\n      // Lägg till total för lärosätet\n      distributions.push({\n        universityId: university.id,\n        year,\n        maleApplicants: Math.floor(totalApplicants * maleBias),\n        femaleApplicants: Math.floor(totalApplicants * femaleBias),\n        otherApplicants: Math.floor(totalApplicants * otherBias),\n        maleAccepted: Math.floor(totalAccepted * maleBias),\n        femaleAccepted: Math.floor(totalAccepted * femaleBias),\n        otherAccepted: Math.floor(totalAccepted * otherBias)\n      });\n\n      // Lägg till för varje program\n      programs.forEach(program => {\n        const programApplicants = 400 + Math.floor(Math.random() * 300) + (year - 2015) * 30;\n        const programAccepted = Math.floor(programApplicants * (0.15 + Math.random() * 0.15));\n\n        // Hämta programmets typiska könsfördelning\n        const genderBias = programGenderBias[program.type];\n\n        // Justera för förändringar över tid (gradvis jämnare fördelning)\n        let maleRatio = genderBias.male - yearFactor * (genderBias.male > 0.5 ? 1 : -1);\n        let femaleRatio = genderBias.female + yearFactor * (genderBias.female < 0.5 ? 1 : -1);\n        const otherRatio = genderBias.other;\n\n        // Normalisera för att säkerställa att summan blir 100%\n        const totalRatio = maleRatio + femaleRatio + otherRatio;\n        maleRatio = maleRatio / totalRatio;\n        femaleRatio = femaleRatio / totalRatio;\n        distributions.push({\n          universityId: university.id,\n          year,\n          programId: program.id,\n          programName: program.name,\n          maleApplicants: Math.floor(programApplicants * maleRatio),\n          femaleApplicants: Math.floor(programApplicants * femaleRatio),\n          otherApplicants: Math.floor(programApplicants * otherRatio),\n          maleAccepted: Math.floor(programAccepted * maleRatio),\n          femaleAccepted: Math.floor(programAccepted * femaleRatio),\n          otherAccepted: Math.floor(programAccepted * otherRatio)\n        });\n      });\n    }\n  });\n  return distributions;\n};\nconst mockStatistics = generateMockStatistics();\nconst mockGeographicDistributions = generateMockGeographicDistribution();\nconst mockGenderDistributions = generateMockGenderDistribution();\n\n// Hämta alla lärosäten\nexport const getUniversities = async () => {\n  // I en riktig applikation skulle vi hämta data från en API\n  // return axios.get<University[]>('/api/universities').then(response => response.data);\n\n  return Promise.resolve(mockUniversities);\n};\n\n// Hämta alla regioner\nexport const getRegions = async () => {\n  return Promise.resolve(mockRegions);\n};\n\n// Hämta statistik baserat på filter\nexport const getStatistics = async filter => {\n  // I en riktig applikation skulle vi hämta data från en API\n  // return axios.get<ProgramStatistics[]>('/api/statistics', { params: filter }).then(response => response.data);\n\n  let filteredStats = [...mockStatistics];\n  if (filter.universityId) {\n    filteredStats = filteredStats.filter(stat => stat.universityId === filter.universityId);\n  }\n  if (filter.fromYear) {\n    filteredStats = filteredStats.filter(stat => stat.year >= filter.fromYear);\n  }\n  if (filter.toYear) {\n    filteredStats = filteredStats.filter(stat => stat.year <= filter.toYear);\n  }\n  if (filter.programId) {\n    filteredStats = filteredStats.filter(stat => stat.id.startsWith(filter.programId));\n  }\n  return Promise.resolve(filteredStats);\n};\n\n// Hämta aggregerad statistik för ett lärosäte\nexport const getUniversityStatistics = async universityId => {\n  const stats = await getStatistics({\n    universityId\n  });\n\n  // Gruppera efter år\n  const yearGroups = {};\n  stats.forEach(stat => {\n    if (!yearGroups[stat.year]) {\n      yearGroups[stat.year] = [];\n    }\n    yearGroups[stat.year].push(stat);\n  });\n\n  // Skapa aggregerad statistik per år\n  const universityStats = Object.keys(yearGroups).map(yearStr => {\n    const year = parseInt(yearStr);\n    const programs = yearGroups[year];\n    const totalApplicants = programs.reduce((sum, prog) => sum + prog.applicants, 0);\n    const totalAcceptedStudents = programs.reduce((sum, prog) => sum + prog.acceptedStudents, 0);\n    return {\n      universityId,\n      year,\n      totalApplicants,\n      totalAcceptedStudents,\n      programs\n    };\n  });\n  return universityStats.sort((a, b) => a.year - b.year);\n};\n\n// Hämta geografisk fördelning för ett lärosäte\nexport const getGeographicDistribution = async (universityId, year) => {\n  let filteredDistributions = [...mockGeographicDistributions].filter(dist => dist.universityId === universityId);\n  if (year) {\n    filteredDistributions = filteredDistributions.filter(dist => dist.year === year);\n  }\n  return Promise.resolve(filteredDistributions.sort((a, b) => a.year - b.year));\n};\n\n// Hämta könsfördelning för ett lärosäte\nexport const getGenderDistribution = async (universityId, year, programId) => {\n  let filteredDistributions = [...mockGenderDistributions].filter(dist => dist.universityId === universityId);\n  if (year) {\n    filteredDistributions = filteredDistributions.filter(dist => dist.year === year);\n  }\n  if (programId) {\n    filteredDistributions = filteredDistributions.filter(dist => dist.programId === programId);\n  }\n  return Promise.resolve(filteredDistributions.sort((a, b) => {\n    // Sortera först efter år\n    if (a.year !== b.year) return a.year - b.year;\n\n    // Sedan sortera så att totalen för lärosätet kommer först\n    if (!a.programId && b.programId) return -1;\n    if (a.programId && !b.programId) return 1;\n\n    // Slutligen sortera program alfabetiskt\n    if (a.programName && b.programName) {\n      return a.programName.localeCompare(b.programName);\n    }\n    return 0;\n  }));\n};","map":{"version":3,"names":["mockUniversities","id","name","mockRegions","programGenderBias","male","female","other","generateMockStatistics","statistics","forEach","university","programs","program","year","baseApplicants","Math","floor","random","yearFactor","randomFactor","applicants","acceptedStudents","firstHandApplicants","push","universityId","generateMockGeographicDistribution","distributions","regionData","totalPercentage","nearbyRegions","region","percentage","includes","totalApplicants","applicantCount","regionId","regionName","data","sort","a","b","generateMockGenderDistribution","type","totalAccepted","maleBias","femaleBias","otherBias","totalBias","maleApplicants","femaleApplicants","otherApplicants","maleAccepted","femaleAccepted","otherAccepted","programApplicants","programAccepted","genderBias","maleRatio","femaleRatio","otherRatio","totalRatio","programId","programName","mockStatistics","mockGeographicDistributions","mockGenderDistributions","getUniversities","Promise","resolve","getRegions","getStatistics","filter","filteredStats","stat","fromYear","toYear","startsWith","getUniversityStatistics","stats","yearGroups","universityStats","Object","keys","map","yearStr","parseInt","reduce","sum","prog","totalAcceptedStudents","getGeographicDistribution","filteredDistributions","dist","getGenderDistribution","localeCompare"],"sources":["C:/Users/saak0033/source/repos/IP/src/services/statisticsService.ts"],"sourcesContent":["import axios from 'axios';\r\nimport { University, ProgramStatistics, UniversityStatistics, StatisticsFilter, GeographicDistribution, RegionData, Region, GenderDistribution } from '../models/types';\r\n\r\n// Simulerad data för demonstration\r\nconst mockUniversities: University[] = [\r\n  { id: 'kth', name: 'Kungliga Tekniska Högskolan' },\r\n  { id: 'su', name: 'Stockholms Universitet' },\r\n  { id: 'uu', name: 'Uppsala Universitet' },\r\n  { id: 'lu', name: 'Lunds Universitet' },\r\n  { id: 'gu', name: 'Göteborgs Universitet' },\r\n];\r\n\r\n// Svenska regioner\r\nconst mockRegions: Region[] = [\r\n  { id: 'stockholm', name: 'Stockholm' },\r\n  { id: 'uppsala', name: 'Uppsala' },\r\n  { id: 'skane', name: 'Skåne' },\r\n  { id: 'vastra_gotaland', name: 'Västra Götaland' },\r\n  { id: 'ostergotland', name: 'Östergötland' },\r\n  { id: 'norrbotten', name: 'Norrbotten' },\r\n  { id: 'vasterbotten', name: 'Västerbotten' },\r\n  { id: 'jamtland', name: 'Jämtland' },\r\n  { id: 'dalarna', name: 'Dalarna' },\r\n  { id: 'orebro', name: 'Örebro' },\r\n  { id: 'vastmanland', name: 'Västmanland' },\r\n  { id: 'sodermanland', name: 'Södermanland' },\r\n  { id: 'gavleborg', name: 'Gävleborg' },\r\n  { id: 'varmland', name: 'Värmland' },\r\n  { id: 'jonkoping', name: 'Jönköping' },\r\n  { id: 'kalmar', name: 'Kalmar' },\r\n  { id: 'kronoberg', name: 'Kronoberg' },\r\n  { id: 'blekinge', name: 'Blekinge' },\r\n  { id: 'halland', name: 'Halland' },\r\n  { id: 'gotland', name: 'Gotland' },\r\n  { id: 'vasternorrland', name: 'Västernorrland' },\r\n];\r\n\r\n// Program med typisk könsfördelning\r\nconst programGenderBias: { [key: string]: { male: number, female: number, other: number } } = {\r\n  'cs': { male: 0.75, female: 0.23, other: 0.02 },  // Datavetenskap - mansdominerad\r\n  'eng': { male: 0.65, female: 0.33, other: 0.02 }, // Civilingenjör - mansdominerad\r\n  'med': { male: 0.35, female: 0.63, other: 0.02 }, // Läkarprogrammet - kvinnodominerad\r\n};\r\n\r\n// Generera simulerad statistik för demonstration\r\nconst generateMockStatistics = (): ProgramStatistics[] => {\r\n  const statistics: ProgramStatistics[] = [];\r\n  \r\n  mockUniversities.forEach(university => {\r\n    const programs = [\r\n      { id: `${university.id}-cs`, name: 'Datavetenskap' },\r\n      { id: `${university.id}-eng`, name: 'Civilingenjör' },\r\n      { id: `${university.id}-med`, name: 'Läkarprogrammet' },\r\n    ];\r\n    \r\n    programs.forEach(program => {\r\n      for (let year = 2015; year <= 2023; year++) {\r\n        // Simulera en trend med ökande antal sökande\r\n        const baseApplicants = 500 + Math.floor(Math.random() * 500);\r\n        const yearFactor = (year - 2015) * 50;\r\n        const randomFactor = Math.floor(Math.random() * 200) - 100;\r\n        \r\n        const applicants = baseApplicants + yearFactor + randomFactor;\r\n        const acceptedStudents = Math.floor(applicants * (0.1 + Math.random() * 0.2));\r\n        const firstHandApplicants = Math.floor(applicants * (0.4 + Math.random() * 0.3));\r\n        \r\n        statistics.push({\r\n          id: `${program.id}-${year}`,\r\n          name: program.name,\r\n          universityId: university.id,\r\n          year,\r\n          applicants,\r\n          acceptedStudents,\r\n          firstHandApplicants\r\n        });\r\n      }\r\n    });\r\n  });\r\n  \r\n  return statistics;\r\n};\r\n\r\n// Generera simulerad geografisk fördelning\r\nconst generateMockGeographicDistribution = (): GeographicDistribution[] => {\r\n  const distributions: GeographicDistribution[] = [];\r\n  \r\n  mockUniversities.forEach(university => {\r\n    for (let year = 2015; year <= 2023; year++) {\r\n      // Skapa en fördelning baserad på lärosätets geografiska läge\r\n      // Högre procent från närliggande regioner\r\n      const regionData: RegionData[] = [];\r\n      let totalPercentage = 0;\r\n      \r\n      // Bestäm vilka regioner som är \"nära\" lärosätet\r\n      const nearbyRegions: string[] = [];\r\n      switch (university.id) {\r\n        case 'kth':\r\n        case 'su':\r\n          nearbyRegions.push('stockholm', 'uppsala', 'sodermanland');\r\n          break;\r\n        case 'uu':\r\n          nearbyRegions.push('uppsala', 'stockholm', 'vastmanland');\r\n          break;\r\n        case 'lu':\r\n          nearbyRegions.push('skane', 'blekinge', 'halland');\r\n          break;\r\n        case 'gu':\r\n          nearbyRegions.push('vastra_gotaland', 'halland', 'varmland');\r\n          break;\r\n      }\r\n      \r\n      // Fördela sökande över regioner\r\n      mockRegions.forEach(region => {\r\n        let percentage: number;\r\n        \r\n        if (nearbyRegions.includes(region.id)) {\r\n          // Högre procent från närliggande regioner (10-25%)\r\n          percentage = 10 + Math.random() * 15;\r\n        } else {\r\n          // Lägre procent från andra regioner (1-5%)\r\n          percentage = 1 + Math.random() * 4;\r\n        }\r\n        \r\n        // Justera för att säkerställa att summan blir 100%\r\n        totalPercentage += percentage;\r\n        \r\n        // Simulera antalet sökande baserat på procent\r\n        // Anta att vi har totalt 1000-3000 sökande per år\r\n        const totalApplicants = 1000 + Math.floor(Math.random() * 2000);\r\n        const applicantCount = Math.floor((percentage / 100) * totalApplicants);\r\n        \r\n        regionData.push({\r\n          regionId: region.id,\r\n          regionName: region.name,\r\n          applicantCount,\r\n          percentage\r\n        });\r\n      });\r\n      \r\n      // Normalisera procentandelarna så att summan blir 100%\r\n      regionData.forEach(data => {\r\n        data.percentage = (data.percentage / totalPercentage) * 100;\r\n      });\r\n      \r\n      // Sortera efter antal sökande (fallande)\r\n      regionData.sort((a, b) => b.applicantCount - a.applicantCount);\r\n      \r\n      distributions.push({\r\n        universityId: university.id,\r\n        year,\r\n        regionData\r\n      });\r\n    }\r\n  });\r\n  \r\n  return distributions;\r\n};\r\n\r\n// Generera simulerad könsfördelning\r\nconst generateMockGenderDistribution = (): GenderDistribution[] => {\r\n  const distributions: GenderDistribution[] = [];\r\n  \r\n  // För varje lärosäte\r\n  mockUniversities.forEach(university => {\r\n    // För varje år\r\n    for (let year = 2015; year <= 2023; year++) {\r\n      // För varje program\r\n      const programs = [\r\n        { id: `${university.id}-cs`, name: 'Datavetenskap', type: 'cs' },\r\n        { id: `${university.id}-eng`, name: 'Civilingenjör', type: 'eng' },\r\n        { id: `${university.id}-med`, name: 'Läkarprogrammet', type: 'med' },\r\n      ];\r\n      \r\n      // Lägg till en total för hela lärosätet\r\n      const totalApplicants = 1500 + Math.floor(Math.random() * 1000) + (year - 2015) * 100;\r\n      const totalAccepted = Math.floor(totalApplicants * (0.2 + Math.random() * 0.1));\r\n      \r\n      // Beräkna genomsnittlig könsfördelning för lärosätet\r\n      // Anta en gradvis förändring mot jämnare könsfördelning över tid\r\n      const yearFactor = (year - 2015) * 0.005; // Små förändringar per år\r\n      \r\n      // Genomsnittlig könsfördelning för lärosätet\r\n      let maleBias = 0.55 - yearFactor; // Startar med 55% män, minskar något över tid\r\n      let femaleBias = 0.43 + yearFactor; // Startar med 43% kvinnor, ökar något över tid\r\n      const otherBias = 0.02; // Konstant 2% övriga\r\n      \r\n      // Justera för att säkerställa att summan blir 100%\r\n      const totalBias = maleBias + femaleBias + otherBias;\r\n      maleBias = maleBias / totalBias;\r\n      femaleBias = femaleBias / totalBias;\r\n      \r\n      // Lägg till total för lärosätet\r\n      distributions.push({\r\n        universityId: university.id,\r\n        year,\r\n        maleApplicants: Math.floor(totalApplicants * maleBias),\r\n        femaleApplicants: Math.floor(totalApplicants * femaleBias),\r\n        otherApplicants: Math.floor(totalApplicants * otherBias),\r\n        maleAccepted: Math.floor(totalAccepted * maleBias),\r\n        femaleAccepted: Math.floor(totalAccepted * femaleBias),\r\n        otherAccepted: Math.floor(totalAccepted * otherBias)\r\n      });\r\n      \r\n      // Lägg till för varje program\r\n      programs.forEach(program => {\r\n        const programApplicants = 400 + Math.floor(Math.random() * 300) + (year - 2015) * 30;\r\n        const programAccepted = Math.floor(programApplicants * (0.15 + Math.random() * 0.15));\r\n        \r\n        // Hämta programmets typiska könsfördelning\r\n        const genderBias = programGenderBias[program.type];\r\n        \r\n        // Justera för förändringar över tid (gradvis jämnare fördelning)\r\n        let maleRatio = genderBias.male - yearFactor * (genderBias.male > 0.5 ? 1 : -1);\r\n        let femaleRatio = genderBias.female + yearFactor * (genderBias.female < 0.5 ? 1 : -1);\r\n        const otherRatio = genderBias.other;\r\n        \r\n        // Normalisera för att säkerställa att summan blir 100%\r\n        const totalRatio = maleRatio + femaleRatio + otherRatio;\r\n        maleRatio = maleRatio / totalRatio;\r\n        femaleRatio = femaleRatio / totalRatio;\r\n        \r\n        distributions.push({\r\n          universityId: university.id,\r\n          year,\r\n          programId: program.id,\r\n          programName: program.name,\r\n          maleApplicants: Math.floor(programApplicants * maleRatio),\r\n          femaleApplicants: Math.floor(programApplicants * femaleRatio),\r\n          otherApplicants: Math.floor(programApplicants * otherRatio),\r\n          maleAccepted: Math.floor(programAccepted * maleRatio),\r\n          femaleAccepted: Math.floor(programAccepted * femaleRatio),\r\n          otherAccepted: Math.floor(programAccepted * otherRatio)\r\n        });\r\n      });\r\n    }\r\n  });\r\n  \r\n  return distributions;\r\n};\r\n\r\nconst mockStatistics = generateMockStatistics();\r\nconst mockGeographicDistributions = generateMockGeographicDistribution();\r\nconst mockGenderDistributions = generateMockGenderDistribution();\r\n\r\n// Hämta alla lärosäten\r\nexport const getUniversities = async (): Promise<University[]> => {\r\n  // I en riktig applikation skulle vi hämta data från en API\r\n  // return axios.get<University[]>('/api/universities').then(response => response.data);\r\n  \r\n  return Promise.resolve(mockUniversities);\r\n};\r\n\r\n// Hämta alla regioner\r\nexport const getRegions = async (): Promise<Region[]> => {\r\n  return Promise.resolve(mockRegions);\r\n};\r\n\r\n// Hämta statistik baserat på filter\r\nexport const getStatistics = async (filter: StatisticsFilter): Promise<ProgramStatistics[]> => {\r\n  // I en riktig applikation skulle vi hämta data från en API\r\n  // return axios.get<ProgramStatistics[]>('/api/statistics', { params: filter }).then(response => response.data);\r\n  \r\n  let filteredStats = [...mockStatistics];\r\n  \r\n  if (filter.universityId) {\r\n    filteredStats = filteredStats.filter(stat => stat.universityId === filter.universityId);\r\n  }\r\n  \r\n  if (filter.fromYear) {\r\n    filteredStats = filteredStats.filter(stat => stat.year >= filter.fromYear!);\r\n  }\r\n  \r\n  if (filter.toYear) {\r\n    filteredStats = filteredStats.filter(stat => stat.year <= filter.toYear!);\r\n  }\r\n  \r\n  if (filter.programId) {\r\n    filteredStats = filteredStats.filter(stat => stat.id.startsWith(filter.programId!));\r\n  }\r\n  \r\n  return Promise.resolve(filteredStats);\r\n};\r\n\r\n// Hämta aggregerad statistik för ett lärosäte\r\nexport const getUniversityStatistics = async (universityId: string): Promise<UniversityStatistics[]> => {\r\n  const stats = await getStatistics({ universityId });\r\n  \r\n  // Gruppera efter år\r\n  const yearGroups: { [key: number]: ProgramStatistics[] } = {};\r\n  stats.forEach(stat => {\r\n    if (!yearGroups[stat.year]) {\r\n      yearGroups[stat.year] = [];\r\n    }\r\n    yearGroups[stat.year].push(stat);\r\n  });\r\n  \r\n  // Skapa aggregerad statistik per år\r\n  const universityStats: UniversityStatistics[] = Object.keys(yearGroups).map(yearStr => {\r\n    const year = parseInt(yearStr);\r\n    const programs = yearGroups[year];\r\n    \r\n    const totalApplicants = programs.reduce((sum, prog) => sum + prog.applicants, 0);\r\n    const totalAcceptedStudents = programs.reduce((sum, prog) => sum + prog.acceptedStudents, 0);\r\n    \r\n    return {\r\n      universityId,\r\n      year,\r\n      totalApplicants,\r\n      totalAcceptedStudents,\r\n      programs\r\n    };\r\n  });\r\n  \r\n  return universityStats.sort((a, b) => a.year - b.year);\r\n};\r\n\r\n// Hämta geografisk fördelning för ett lärosäte\r\nexport const getGeographicDistribution = async (universityId: string, year?: number): Promise<GeographicDistribution[]> => {\r\n  let filteredDistributions = [...mockGeographicDistributions].filter(\r\n    dist => dist.universityId === universityId\r\n  );\r\n  \r\n  if (year) {\r\n    filteredDistributions = filteredDistributions.filter(dist => dist.year === year);\r\n  }\r\n  \r\n  return Promise.resolve(filteredDistributions.sort((a, b) => a.year - b.year));\r\n};\r\n\r\n// Hämta könsfördelning för ett lärosäte\r\nexport const getGenderDistribution = async (\r\n  universityId: string, \r\n  year?: number, \r\n  programId?: string\r\n): Promise<GenderDistribution[]> => {\r\n  let filteredDistributions = [...mockGenderDistributions].filter(\r\n    dist => dist.universityId === universityId\r\n  );\r\n  \r\n  if (year) {\r\n    filteredDistributions = filteredDistributions.filter(dist => dist.year === year);\r\n  }\r\n  \r\n  if (programId) {\r\n    filteredDistributions = filteredDistributions.filter(dist => dist.programId === programId);\r\n  }\r\n  \r\n  return Promise.resolve(filteredDistributions.sort((a, b) => {\r\n    // Sortera först efter år\r\n    if (a.year !== b.year) return a.year - b.year;\r\n    \r\n    // Sedan sortera så att totalen för lärosätet kommer först\r\n    if (!a.programId && b.programId) return -1;\r\n    if (a.programId && !b.programId) return 1;\r\n    \r\n    // Slutligen sortera program alfabetiskt\r\n    if (a.programName && b.programName) {\r\n      return a.programName.localeCompare(b.programName);\r\n    }\r\n    \r\n    return 0;\r\n  }));\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}